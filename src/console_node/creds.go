//
//  MIT License
//
//  (C) Copyright 2020-2022, 2024 Hewlett Packard Enterprise Development LP
//
//  Permission is hereby granted, free of charge, to any person obtaining a
//  copy of this software and associated documentation files (the "Software"),
//  to deal in the Software without restriction, including without limitation
//  the rights to use, copy, modify, merge, publish, distribute, sublicense,
//  and/or sell copies of the Software, and to permit persons to whom the
//  Software is furnished to do so, subject to the following conditions:
//
//  The above copyright notice and this permission notice shall be included
//  in all copies or substantial portions of the Software.
//
//  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
//  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
//  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
//  THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR
//  OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
//  ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
//  OTHER DEALINGS IN THE SOFTWARE.
//

// This file contains the functions to configure and retrieve credentials

package main

import (
	"bytes"
	"crypto/sha256"
	"encoding/json"
	"fmt"
	"log"
	"net/http"
	"os"
	"time"

	"github.com/tidwall/gjson"

	compcreds "github.com/Cray-HPE/hms-compcredentials"
	sstorage "github.com/Cray-HPE/hms-securestorage"
)

// Location of the Mountain BMC console ssh key pair files.
// These are obtained or generated by console-operator.
const mountainConsoleKey string = "/app/conman.key"
const mountainConsoleKeyPub string = "/app/conman.key.pub"

// Location of the Kubernetes service account token used to authenticate
// to Vault.  This is part of the pod deployment.
const svcAcctTokenFile string = "/var/run/secrets/kubernetes.io/serviceaccount/token"

// Look up the creds for the input endpoints with retries
func getPasswordsWithRetries(bmcXNames []string, maxTries, waitSecs int) map[string]compcreds.CompCredentials {
	// NOTE: in update config thread

	var passwords map[string]compcreds.CompCredentials = nil
	for numTries := 0; numTries < maxTries; numTries++ {
		log.Printf("Get passwords with retry: %d", numTries)
		// get passwords from vault
		passwords = getPasswords(bmcXNames)

		// make sure we have something for all entries
		foundAll := true
		for _, nn := range bmcXNames {
			_, ok := passwords[nn]
			if !ok {
				log.Printf("Missing credentials for %s", nn)
				foundAll = false
			}
		}

		// if we got all the passwords we are done
		if foundAll {
			log.Printf("Retrieved all passwords")
			return passwords
		}

		// if we did not get all passwords try again until maxAttempts
		log.Printf("Attempt %d - Only retrieved %d of %d River creds from vault, waiting and trying again...",
			numTries, len(passwords), len(bmcXNames))
		time.Sleep(time.Duration(waitSecs) * time.Second)
	}

	// We have reached max attempts, bail with what we have
	log.Printf("Maximum password attempts reached, configuring conman with what we have.")
	return passwords
}

// Look up the creds for the input endpoints
func getPasswords(bmcXNames []string) map[string]compcreds.CompCredentials {
	// NOTE: in update config thread

	// if running in debug mode, skip hsm query
	if debugOnly {
		log.Print("DEBUGONLY mode - skipping creds query")
		return nil
	}

	// Get the passwords from Hashicorp Vault
	log.Print("Gathering creds from vault")

	// Create the Vault adapter and connect to Vault
	ss, err := sstorage.NewVaultAdapter("secret")
	if err != nil {
		log.Panicf("Error: %#v\n", err)
	}

	// Initialize the CompCredStore struct with the Vault adapter.
	ccs := compcreds.NewCompCredStore("hms-creds", ss)

	// Read the credentials for a list of components from the CompCredStore
	// (backed by Vault).
	ccreds, err := ccs.GetCompCreds(bmcXNames)
	if err != nil {
		log.Panicf("Error: %#v\n", err)
	}

	return ccreds
}

// Ask vault for the private key
func vaultExportPrivateKey(vaultToken string) (pvtKey string, response []byte, responseCode int, err error) {
	// get the vault base URL
	vaultBase := os.Getenv("VAULT_URL")
	if len(vaultBase) == 0 {
		log.Printf("Error: VAULT_URL environment variable is not set, defaulting to http://cray-vault.vault:8200/v1")
		vaultBase = "http://cray-vault.vault:8200/v1"
	}

	// get the name of the vault secret
	vaultBmcKeyName := os.Getenv("VAULT_BMC_KEY_NAME")
	if len(vaultBmcKeyName) == 0 {
		log.Printf("Error: VAULT_BMC_KEY_NAME environment variable is not set, defaulting to bmc-console-key")
		vaultBmcKeyName = "mountain-bmc-console"
	}

	// query vault for the private key
	URL := vaultBase + "/transit/export/signing-key/" + vaultBmcKeyName
	vaultRequestHeaders := make(map[string]string)
	vaultRequestHeaders["X-Vault-Token"] = vaultToken
	response, responseCode, err = getURL(URL, vaultRequestHeaders)
	// Handle any general error with the request.
	if err != nil {
		log.Printf(
			"Unable to get the %s secret from vault: %s  Error was: %s",
			vaultBmcKeyName, vaultBase, err)
		return "", response, responseCode, fmt.Errorf("Unable to get the %s secret from vault: %s  Error was: %s",
			vaultBmcKeyName, vaultBase, err)
	}

	if responseCode == http.StatusNotFound {
		log.Printf("The vault secret %s was not found. It will need to be created.", vaultBmcKeyName)
		return "", response, http.StatusNotFound, nil
	} else if responseCode == http.StatusOK {
		// Return the secret we found
		jsonElem := "data.keys.1" // See https://github.com/tidwall/gjson#path-syntax
		pvtKey := gjson.Get(string(response), jsonElem)
		if len(pvtKey.String()) == 0 {
			log.Printf(
				"Empty or missing %s element in Vault response",
				jsonElem)
			return "", response, responseCode, fmt.Errorf("Empty or missing %s element in Vault response",
				jsonElem)
		}
		log.Printf("Successfully retrieved the %s secret from Vault", vaultBmcKeyName)
		return pvtKey.String(), response, http.StatusOK, nil
	} else {
		// Return an error for any unhandled http response code.
		log.Printf(
			"Unexpected response from Vault: %s  Http response code: %d",
			response, responseCode)
		return "", response, responseCode, fmt.Errorf("Unexpected response from Vault: %s  Http response code: %d",
			response, responseCode)
	}
}

var previousPrivateKeyHash []byte = nil

// function to hash a string
func hashString(s string) ([]byte, error) {
	hasher := sha256.New()
	if _, err := hasher.Write([]byte(s)); err != nil {
		return nil, err
	}
	return hasher.Sum(nil), nil
}

// Ensure that Mountain node console key files are present.
func ensureMountainConsoleKeysPresent() bool {
	// NOTE: in update config thread
	retVal := false

	// if running in debug mode there won't be any nodes or vault present
	if debugOnly {
		log.Print("Running in debug mode - skipping mountain cred generation")
		return retVal
	}

	// if there are no mountain nodes configured do not download the ssh key
	if len(currentMtnNodes) == 0 {
		log.Printf("No mountain nodes configured, not checking for keys")
		return retVal
	}

	// Authenticate to Vault
	svcAcctToken, err := os.ReadFile(svcAcctTokenFile)
	if err != nil {
		log.Printf("Unable to read the service account token file: %s  Can not authenticate to vault.", err)
		return retVal
	}

	// get the vault base URL
	vaultBase := os.Getenv("VAULT_URL")
	if len(vaultBase) == 0 {
		log.Printf("Error: VAULT_URL environment variable is not set, defaulting to http://cray-vault.vault:8200/v1")
		vaultBase = "http://cray-vault.vault:8200/v1"
	}

	// Authenticate to Vault using the service account token

	// The ssh key is created and deployed by console-operator, this just waits until
	// it is available in vault and downloads it to the local file system for use.
	vaultToken := ""
	for {
		// Authenticate to Vault using the service account token
		vaultAuthParam := map[string]string{
			"jwt":  string(svcAcctToken),
			"role": "ssh-user-certs-compute"}
		jsonVaultAuthParam, err := json.Marshal(vaultAuthParam)
		if err != nil {
			log.Printf("Error: Failed to marshal the vault authentication parameters. Err: %s", err)
		} else {
			URL := vaultBase + "/auth/kubernetes/login"
			log.Printf("Attempting to authenticate to Vault at: %s", URL)
			response, responseCode, _ := postURL(URL, jsonVaultAuthParam, nil)

			// If the response code is not 200 then we failed authentication.
			if responseCode == http.StatusOK {
				log.Printf("Vault authentication was successful.  Attempting to get BMC console key from vault")
				vaultToken = gjson.Get(string(response), "auth.client_token").String()
				break
			}
		}

		// Can't access vault, wait and try again
		log.Printf("Unable to authenticate with vault, will try again in 15 seconds")
		time.Sleep(15 * time.Second)
	}

	// Authentication was successful, now retrieve the private key.
	for {
		// Ask vault for the existing key
		pvtKey, _, responseCode, _ := vaultExportPrivateKey(vaultToken)
		if responseCode == http.StatusOK {
			// see if this is the same key as before
			newHash, err := hashString(pvtKey)
			if err != nil {
				log.Printf("Error: Failed to hash the private ssh key received from Vault. Err: %s", err)
			} else if previousPrivateKeyHash == nil || !(bytes.Equal(newHash, previousPrivateKeyHash)) {
				// This is a new key
				retVal = true
				previousPrivateKeyHash = newHash

				// Write the private key to the local file system.
				err = os.WriteFile(mountainConsoleKey, []byte(pvtKey), 0600)
				if err != nil {
					log.Printf("Error: Failed to write our the private ssh key received from Vault. Err: %s", err)
					continue
				}
				log.Printf("Mountain ssh key file created")
				return retVal
			} else {
				// This is the same key as before, no need to write it again
				log.Printf("Mountain ssh key file already exists")
				return retVal
			}
		}

		// keys do not exist, wait and try again
		log.Printf("Mountain ssh keys do not exist - waiting for them...")
		time.Sleep(5 * time.Second)
	}
}
