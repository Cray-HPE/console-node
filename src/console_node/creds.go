//
//  MIT License
//
//  (C) Copyright 2020-2022 Hewlett Packard Enterprise Development LP
//
//  Permission is hereby granted, free of charge, to any person obtaining a
//  copy of this software and associated documentation files (the "Software"),
//  to deal in the Software without restriction, including without limitation
//  the rights to use, copy, modify, merge, publish, distribute, sublicense,
//  and/or sell copies of the Software, and to permit persons to whom the
//  Software is furnished to do so, subject to the following conditions:
//
//  The above copyright notice and this permission notice shall be included
//  in all copies or substantial portions of the Software.
//
//  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
//  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
//  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
//  THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR
//  OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
//  ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
//  OTHER DEALINGS IN THE SOFTWARE.
//

// This file contains the functions to configure and retrieve credentials

package main

import (
	"encoding/json"
	"fmt"
	"io/ioutil"
	"log"
	"os"
	"time"

	"github.com/tidwall/gjson"

	compcreds "github.com/Cray-HPE/hms-compcredentials"
	sstorage "github.com/Cray-HPE/hms-securestorage"
)

// Location of the Mountain BMC console ssh key pair files.
// These are obtained or generated by console-operator.
const mountainConsoleKey string = "/app/conman.key"

// Look up the creds for the input endpoints with retries
func getPasswordsWithRetries(bmcXNames []string, maxTries, waitSecs int) map[string]compcreds.CompCredentials {
	// NOTE: in update config thread

	var passwords map[string]compcreds.CompCredentials = nil
	for numTries := 0; numTries < maxTries; numTries++ {
		log.Printf("Get passwords with retry: %d", numTries)
		// get passwords from vault
		passwords = getPasswords(bmcXNames)

		// make sure we have something for all entries
		foundAll := true
		for _, nn := range bmcXNames {
			_, ok := passwords[nn]
			if !ok {
				log.Printf("Missing credentials for %s", nn)
				foundAll = false
			}
		}

		// if we got all the passwords we are done
		if foundAll {
			log.Printf("Retrieved all passwords")
			return passwords
		}

		// if we did not get all passwords try again until maxAttempts
		log.Printf("Attempt %d - Only retrieved %d of %d River creds from vault, waiting and trying again...",
			numTries, len(passwords), len(bmcXNames))
		time.Sleep(time.Duration(waitSecs) * time.Second)
	}

	// We have reached max attempts, bail with what we have
	log.Printf("Maximum password attempts reached, configuring conman with what we have.")
	return passwords
}

// Look up the creds for the input endpoints
func getPasswords(bmcXNames []string) map[string]compcreds.CompCredentials {
	// NOTE: in update config thread

	// if running in debug mode, skip hsm query
	if debugOnly {
		log.Print("DEBUGONLY mode - skipping creds query")
		return nil
	}

	// Get the passwords from Hashicorp Vault
	log.Print("Gathering creds from vault")

	// Create the Vault adapter and connect to Vault
	ss, err := sstorage.NewVaultAdapter("secret")
	if err != nil {
		log.Panicf("Error: %#v\n", err)
	}

	// Initialize the CompCredStore struct with the Vault adapter.
	ccs := compcreds.NewCompCredStore("hms-creds", ss)

	// Read the credentails for a list of components from the CompCredStore
	// (backed by Vault).
	ccreds, err := ccs.GetCompCreds(bmcXNames)
	if err != nil {
		log.Panicf("Error: %#v\n", err)
	}

	return ccreds
}

// Ensure that Mountain node console key files are present.
func ensureMountainConsoleKeysPresent() {
	// NOTE: in update config thread

	// if running in debug mode there won't be any nodes or vault present
	if debugOnly {
		log.Print("Running in debug mode - skipping mountain cred generation")
		return
	}

	// The ssh key files are created and deployed by console-operator
	// be we want to make sure they exist before continuing to
	// deploy conmand

	// if there are no mountain nodes, no need to wait
	if len(currentMtnNodes) == 0 {
		log.Printf("No mountain nodes configured, not checking for keys")
		return
	}

	// spin forever waiting for keys to be created
	for {
		// Check that we have key pair files on local storage
		_, errKey := os.Stat(mountainConsoleKey)
		noKey := os.IsNotExist(errKey)

		if !noKey {
			// keys exist so done
			log.Printf("Mountain ssh key files exist")
			return
		}

		// see if we can pull the key from vault
		log.Printf("Mountain ssh key file not present - querying vault")
		pvtKey, responseCode, err := vaultExportPrivateKey()
		if err == nil && responseCode == 200 {
			// Write the private key to the local file system.
			err = ioutil.WriteFile(mountainConsoleKey, []byte(pvtKey), 0600)
			if err != nil {
				log.Printf("Error writing mountain ssh key file: %s", err)
			} else {
				// wrote out the key file - return
				log.Printf("Wrote mountain ssh key file to: %s", mountainConsoleKey)
				return
			}
		}

		// keys do not exist, wait and try again
		log.Printf("Mountain ssh keys do not exist - waiting for them...")
		time.Sleep(5 * time.Second)
	}
}

/////////////////////////////////////////////////////////////////

// The Vault base URI
const vaultBase = "http://cray-vault.vault:8200/v1"

// The Vault specific secret name of the Conman Mountain BMC console private key.
// If this secret does not exist Vault will be asked to create it.
const vaultBmcKeyName = "mountain-bmc-console"

// Ask vault for the private key
func vaultExportPrivateKey() (pvtKey string, responseCode int, err error) {
	// get the vault token
	vaultToken, err := getVaultToken()
	if err != nil || vaultToken == "" {
		return "", -1, fmt.Errorf("Unable to get vault token")
	}

	// query vault for the ssh key
	URL := vaultBase + "/transit/export/signing-key/" + vaultBmcKeyName
	vaultRequestHeaders := make(map[string]string)
	vaultRequestHeaders["X-Vault-Token"] = vaultToken
	response, responseCode, err := getURL(URL, vaultRequestHeaders)
	// Handle any general error with the request.
	if err != nil {
		log.Printf(
			"Unable to get the %s secret from vault: %s  Error was: %s",
			vaultBmcKeyName, vaultBase, err)
		return "", responseCode, fmt.Errorf("Unable to get the %s secret from vault: %s  Error was: %s",
			vaultBmcKeyName, vaultBase, err)
	}

	if responseCode == 404 {
		log.Printf("The vault secret %s was not found. It will need to be created.", vaultBmcKeyName)

		return "", 404, nil
	} else if responseCode == 200 {
		// Return the secret we found
		jsonElem := "data.keys.1" // See https://github.com/tidwall/gjson#path-syntax
		pvtKey := gjson.Get(string(response), jsonElem)
		if len(pvtKey.String()) == 0 {
			log.Printf(
				"Empty or missing %s element in Vault response",
				jsonElem)
			return "", responseCode, fmt.Errorf("Empty or missing %s element in Vault response",
				jsonElem)
		}
		return pvtKey.String(), 200, nil
	} else {
		// Return an error for any unhandled http reposponse code.
		log.Printf(
			"Unexpected response from Vault: %s  Http repsonse code: %d",
			response, responseCode)
		return "", responseCode, fmt.Errorf("Unexpected response from Vault: %s  Http repsonse code: %d",
			response, responseCode)
	}
}

// Location of the Kubernetes service account token used to authenticate
// to Vault.  This is part of the pod deployment.
const svcAcctTokenFile string = "/var/run/secrets/kubernetes.io/serviceaccount/token"

// Get the vault authentication token
func getVaultToken() (string, error) {
	// Authenticate to Vault
	svcAcctToken, err := ioutil.ReadFile(svcAcctTokenFile)
	if err != nil {
		log.Printf("Unable to read the service account token file: %s  Can not authenticate to vault.", err)
		return "", fmt.Errorf("Unable to read the service account token file: %s can not authenticate to vault", err)
	}

	vaultAuthParam := map[string]string{
		"jwt":  string(svcAcctToken),
		"role": "ssh-user-certs-compute"}
	jsonVaultAuthParam, _ := json.Marshal(vaultAuthParam)
	URL := vaultBase + "/auth/kubernetes/login"
	log.Printf("Attempting to authenticate to Vault at: %s", URL)
	response, responseCode, err := postURL(URL, jsonVaultAuthParam, nil)
	if err != nil {
		log.Printf("Unable to authenticate to Vault: %s", err)
		return "", fmt.Errorf("Unable to authenticate to Vault: %s", err)
	}
	// If the response code is not 200 then we failed authenticaton.
	if responseCode != 200 {
		log.Printf(
			"Vault authentication failed.  Response code: %d  Message: %s",
			responseCode, string(response))
		return "", fmt.Errorf(
			"Vault authentication failed.  Response code: %d  Message: %s",
			responseCode, string(response))
	}
	log.Printf("Vault authentication was successful.  Attempting to get BMC console key from vault")
	vaultToken := gjson.Get(string(response), "auth.client_token")

	return vaultToken.String(), nil
}
